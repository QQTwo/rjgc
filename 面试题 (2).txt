1抽象类和接口的区别
 1.单继承和多继承（抽象依赖）,接口扩展性更强
 2.类和方法。抽象类关注类，接口关注方法
 3.接口更抽象、抽象相对具体，接口更容易实现多态，便于程序解耦。
 4.抽象类兼顾继承和多态


2,String和StringBufer,StringBuilder的区别，那种用的比较多
  String 字符串常量
  StringBuffer 字符串变量（线程安全）
  StringBuilder 字符串变量（非线程安全）速度快

  在大部分情况下 StringBuffer > String
  在大部分情况下 StringBuilder > StringBuffer

  1,String的长度是不可变的，
  2,对字符串的内容经常操作，特别是内容要修改，最好是使用StringBufer


3，重载和重写的区别，分别在什么时候用？

　override（重写）

　　 1、方法名、参数、返回值相同。
　　 2、子类方法不能缩小父类方法的访问权限。
　　 3、子类方法不能抛出比父类方法更多的异常(但子类方法可以不抛出异常)。
　　 4、存在于父类和子类之间。
　　 5、方法被定义为final不能被重写。

 
overload（重载）
　　1、参数类型、个数、顺序至少有一个不相同。 
　　2、不能重载只有返回值不同的方法名。
　　3、存在于父类和子类、同类中。

重写是父类和子类多态性的表现，
重载是一个类中多态性的表现

5,GC是什么？为什么要有GC?
GC是垃圾回收的意思（gabage collection），内存处理器是编程人员容易出现问题的地方，忘记或者错误的内存回收导致程序或者系统的不稳定甚至崩溃，java的GC功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，java语言没有提供释放已分配内存的俄显示操作方法


6,垃圾回收的有点和原理

 java垃圾回收的优点：它使得Java程序员在编写程序的时候不再需要考虑内存管理。由于有个垃圾回收机制，Java中的对象不再有"作用域"的概念，只有对象的引用才有"作用域"。垃圾回收可以有效的防止内存泄露，有效的使用可以使用的内存。
 java垃圾回收的原理：  垃圾回收器通常是作为一个单独的低级别的线程运行，不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进行清除和回收，程序员不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。回收机制有分代复制垃圾回收和标记垃圾回收，增量垃圾回收。


7，垃圾回收器可以马上垃圾回收器的基本原理是什么？
有什么办法主动通知虚拟机进行垃圾回收吗？

1、对于GC来说，当程序员创建对象时，GC就开始监控这个对象的地址、大小以及使用情况。
通常，GC采用有向图的方式记录和管理堆(heap)中的所有对象。通过这种方式确定哪些对象是"可达的"，哪些对象是"不可达的"。当GC确定一些对象为"不可达"时，GC就有责任回收这些内存空间。

2、可以。程序员可以手动执行System.gc()，通知GC运行，但是Java语言规范并不保证GC一定会执行。



8，java中如何实现多态？

2，多态的定义：指允许不同类的对象对同一消息做出响应。即同一消息可以根据发送对象的不同而采用多种不同的行为方式。（发送消息就是函数调用）

3.实现多态的技术称为：动态绑定（dynamic binding），是指在执行期间判断所引用对象的实际类型，根据其实际的类型调用其相应的方法。


多态的作用：消除类型之间的耦合关系。

多态存在的三个必要条件
一、要有继承；
二、要有重写；
三、父类引用指向子类对象


1.可替换性（substitutability）。多态对已存在代码具有可替换性。
2.可扩充性（extensibility）。多态对代码具有可扩充性。增加新的子类不影响已存在类的多态性、继承性，以及其他特性的运行和操作。实际上新加子类更容易获得多态功能。。
3.接口性（interface-ability）。多态是超类通过方法签名，向子类提供了一个共同接口，由子类来完善或者覆盖它而实现的。
4.灵活性（flexibility）。它在应用中体现了灵活多样的操作，提高了使用效率。
5.简化性（simplicity）。多态简化对应用软件的代码编写和修改过程，尤其在处理大量对象的运算和操作时，这个特点尤为突出和重要。














